{"version":3,"sources":["completer.js"],"names":["defin","$","func","locked","queuedArgsToReplay","uniqueId","initializedEditors","Completer","element","option","this","$el","id","strategies","views","extend","defaults","is","isContentEditable","contentEditable","Error","ownerDocument","activeElement","initialize","self","one","adapter","CKEDITOR","on","event","inArray","editor","push","event2","editable","fn","textcomplete","ckeditor_instance","appendTo","className","dropdownClassName","maxCount","zIndex","rightEdgeOffset","prototype","dropdown","$iframe","Adapter","viewName","get","prop","document","window","frames","length","iframeIndex","frameElement","Dropdown","selectionEnd","destroy","off","deactivate","trigger","text","skipUnchangedTerm","getTextFromHeadToCaret","searchQuery","_extractSearchQuery","term","_term","_search","apply","fire","eventName","args","Array","slice","call","arguments","register","select","value","strategy","e","focus","_clearAtNext","i","context","matchRegexp","isFunction","match","obj","Object","toString","index","free","search","data","stillSearching","shown","activate","clear","setPosition","getCaretPosition","render","_zip","unshift","replayOrFree","replayArgs","undefined","map"],"mappings":"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","file":"../completer.js","sourcesContent":["defin([\n  \"skylark-jquery\",\n  \"./textcomplete\",\n  \"./dropdown\"\n],function ($) {\n  'use strict';\n\n  // Exclusive execution control utility.\n  //\n  // func - The function to be locked. It is executed with a function named\n  //        `free` as the first argument. Once it is called, additional\n  //        execution are ignored until the free is invoked. Then the last\n  //        ignored execution will be replayed immediately.\n  //\n  // Examples\n  //\n  //   var lockedFunc = lock(function (free) {\n  //     setTimeout(function { free(); }, 1000); // It will be free in 1 sec.\n  //     console.log('Hello, world');\n  //   });\n  //   lockedFunc();  // => 'Hello, world'\n  //   lockedFunc();  // none\n  //   lockedFunc();  // none\n  //   // 1 sec past then\n  //   // => 'Hello, world'\n  //   lockedFunc();  // => 'Hello, world'\n  //   lockedFunc();  // none\n  //\n  // Returns a wrapped function.\n  var lock = function (func) {\n    var locked, queuedArgsToReplay;\n\n    return function () {\n      // Convert arguments into a real array.\n      var args = Array.prototype.slice.call(arguments);\n      if (locked) {\n        // Keep a copy of this argument list to replay later.\n        // OK to overwrite a previous value because we only replay\n        // the last one.\n        queuedArgsToReplay = args;\n        return;\n      }\n      locked = true;\n      var self = this;\n      args.unshift(function replayOrFree() {\n        if (queuedArgsToReplay) {\n          // Other request(s) arrived while we were locked.\n          // Now that the lock is becoming available, replay\n          // the latest such request, then call back here to\n          // unlock (or replay another request that arrived\n          // while this one was in flight).\n          var replayArgs = queuedArgsToReplay;\n          queuedArgsToReplay = undefined;\n          replayArgs.unshift(replayOrFree);\n          func.apply(self, replayArgs);\n        } else {\n          locked = false;\n        }\n      });\n      func.apply(this, args);\n    };\n  };\n\n  var isString = function (obj) {\n    return Object.prototype.toString.call(obj) === '[object String]';\n  };\n\n  var uniqueId = 0;\n  var initializedEditors = [];\n\n  function Completer(element, option) {\n    this.$el        = $(element);\n    this.id         = 'textcomplete' + uniqueId++;\n    this.strategies = [];\n    this.views      = [];\n    this.option     = $.extend({}, Completer.defaults, option);\n\n    if (!this.$el.is('input[type=text]') && !this.$el.is('input[type=search]') && !this.$el.is('textarea') && !element.isContentEditable && element.contentEditable != 'true') {\n      throw new Error('textcomplete must be called on a Textarea or a ContentEditable.');\n    }\n\n    // use ownerDocument to fix iframe / IE issues\n    if (element === element.ownerDocument.activeElement) {\n      // element has already been focused. Initialize view objects immediately.\n      this.initialize()\n    } else {\n      // Initialize view objects lazily.\n      var self = this;\n      this.$el.one('focus.' + this.id, function () { self.initialize(); });\n\n      // Special handling for CKEditor: lazy init on instance load\n      if ((!this.option.adapter || this.option.adapter == 'CKEditor') && typeof CKEDITOR != 'undefined' && (this.$el.is('textarea'))) {\n        CKEDITOR.on(\"instanceReady\", function(event) { //For multiple ckeditors on one page: this needs to be executed each time a ckeditor-instance is ready.\n\n          if($.inArray(event.editor.id, initializedEditors) == -1) { //For multiple ckeditors on one page: focus-eventhandler should only be added once for every editor.\n            initializedEditors.push(event.editor.id);\n\t\t\t\n            event.editor.on(\"focus\", function(event2) {\n\t\t\t\t//replace the element with the Iframe element and flag it as CKEditor\n\t\t\t\tself.$el = $(event.editor.editable().$);\n\t\t\t\tif (!self.option.adapter) {\n\t\t\t\t\tself.option.adapter = $.fn.textcomplete['CKEditor'];\n\t\t\t\t}\n\t\t\t\tself.option.ckeditor_instance = event.editor; //For multiple ckeditors on one page: in the old code this was not executed when adapter was alread set. So we were ALWAYS working with the FIRST instance.\n              \tself.initialize();\n            });\n          }\n        });\n      }\n    }\n  }\n\n  Completer.defaults = {\n    appendTo: 'body',\n    className: '',  // deprecated option\n    dropdownClassName: 'dropdown-menu textcomplete-dropdown',\n    maxCount: 10,\n    zIndex: '100',\n    rightEdgeOffset: 30\n  };\n\n  $.extend(Completer.prototype, {\n    // Public properties\n    // -----------------\n\n    id:         null,\n    option:     null,\n    strategies: null,\n    adapter:    null,\n    dropdown:   null,\n    $el:        null,\n    $iframe:    null,\n\n    // Public methods\n    // --------------\n\n    initialize: function () {\n      var element = this.$el.get(0);\n      \n      // check if we are in an iframe\n      // we need to alter positioning logic if using an iframe\n      if (this.$el.prop('ownerDocument') !== document && window.frames.length) {\n        for (var iframeIndex = 0; iframeIndex < window.frames.length; iframeIndex++) {\n          if (this.$el.prop('ownerDocument') === window.frames[iframeIndex].document) {\n            this.$iframe = $(window.frames[iframeIndex].frameElement);\n            break;\n          }\n        }\n      }\n      \n      \n      // Initialize view objects.\n      this.dropdown = new $.fn.textcomplete.Dropdown(element, this, this.option);\n      var Adapter, viewName;\n      if (this.option.adapter) {\n        Adapter = this.option.adapter;\n      } else {\n        if (this.$el.is('textarea') || this.$el.is('input[type=text]') || this.$el.is('input[type=search]')) {\n          viewName = typeof element.selectionEnd === 'number' ? 'Textarea' : 'IETextarea';\n        } else {\n          viewName = 'ContentEditable';\n        }\n        Adapter = $.fn.textcomplete[viewName];\n      }\n      this.adapter = new Adapter(element, this, this.option);\n    },\n\n    destroy: function () {\n      this.$el.off('.' + this.id);\n      if (this.adapter) {\n        this.adapter.destroy();\n      }\n      if (this.dropdown) {\n        this.dropdown.destroy();\n      }\n      this.$el = this.adapter = this.dropdown = null;\n    },\n\n    deactivate: function () {\n      if (this.dropdown) {\n        this.dropdown.deactivate();\n      }\n    },\n\n    // Invoke textcomplete.\n    trigger: function (text, skipUnchangedTerm) {\n      if (!this.dropdown) { this.initialize(); }\n      text != null || (text = this.adapter.getTextFromHeadToCaret());\n      var searchQuery = this._extractSearchQuery(text);\n      if (searchQuery.length) {\n        var term = searchQuery[1];\n        // Ignore shift-key, ctrl-key and so on.\n        if (skipUnchangedTerm && this._term === term && term !== \"\") { return; }\n        this._term = term;\n        this._search.apply(this, searchQuery);\n      } else {\n        this._term = null;\n        this.dropdown.deactivate();\n      }\n    },\n\n    fire: function (eventName) {\n      var args = Array.prototype.slice.call(arguments, 1);\n      this.$el.trigger(eventName, args);\n      return this;\n    },\n\n    register: function (strategies) {\n      Array.prototype.push.apply(this.strategies, strategies);\n    },\n\n    // Insert the value into adapter view. It is called when the dropdown is clicked\n    // or selected.\n    //\n    // value    - The selected element of the array callbacked from search func.\n    // strategy - The Strategy object.\n    // e        - Click or keydown event object.\n    select: function (value, strategy, e) {\n      this._term = null;\n      this.adapter.select(value, strategy, e);\n      this.fire('change').fire('textComplete:select', value, strategy);\n      this.adapter.focus();\n    },\n\n    // Private properties\n    // ------------------\n\n    _clearAtNext: true,\n    _term:        null,\n\n    // Private methods\n    // ---------------\n\n    // Parse the given text and extract the first matching strategy.\n    //\n    // Returns an array including the strategy, the query term and the match\n    // object if the text matches an strategy; otherwise returns an empty array.\n    _extractSearchQuery: function (text) {\n      for (var i = 0; i < this.strategies.length; i++) {\n        var strategy = this.strategies[i];\n        var context = strategy.context(text);\n        if (context || context === '') {\n          var matchRegexp = $.isFunction(strategy.match) ? strategy.match(text) : strategy.match;\n          if (isString(context)) { text = context; }\n          var match = text.match(matchRegexp);\n          if (match) { return [strategy, match[strategy.index], match]; }\n        }\n      }\n      return []\n    },\n\n    // Call the search method of selected strategy..\n    _search: lock(function (free, strategy, term, match) {\n      var self = this;\n      strategy.search(term, function (data, stillSearching) {\n        if (!self.dropdown.shown) {\n          self.dropdown.activate();\n        }\n        if (self._clearAtNext) {\n          // The first callback in the current lock.\n          self.dropdown.clear();\n          self._clearAtNext = false;\n        }\n        self.dropdown.setPosition(self.adapter.getCaretPosition());\n        self.dropdown.render(self._zip(data, strategy, term));\n        if (!stillSearching) {\n          // The last callback in the current lock.\n          free();\n          self._clearAtNext = true; // Call dropdown.clear at the next time.\n        }\n      }, match);\n    }),\n\n    // Build a parameter for Dropdown#render.\n    //\n    // Examples\n    //\n    //  this._zip(['a', 'b'], 's');\n    //  //=> [{ value: 'a', strategy: 's' }, { value: 'b', strategy: 's' }]\n    _zip: function (data, strategy, term) {\n      return $.map(data, function (value) {\n        return { value: value, strategy: strategy, term: term };\n      });\n    }\n  });\n\n  $.fn.textcomplete.Completer = Completer;\n});\n"]}