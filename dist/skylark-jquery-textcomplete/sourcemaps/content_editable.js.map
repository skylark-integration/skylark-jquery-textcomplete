{"version":3,"sources":["content_editable.js"],"names":["define","$","ContentEditable","element","completer","option","this","initialize","extend","prototype","fn","textcomplete","Adapter","select","value","strategy","e","pre","getTextFromHeadToCaret","sel","el","ownerDocument","getSelection","range","getRangeAt","selection","cloneRange","selectNodeContents","startContainer","regExp","post","toString","substring","startOffset","newSubstr","replace","isArray","isFunction","match","deleteContents","preWrapper","createElement","innerHTML","postWrapper","childNode","lastOfPre","fragment","createDocumentFragment","firstChild","appendChild","insertNode","setStartAfter","collapse","removeAllRanges","addRange","_getCaretRelativePosition","wrapperNode","endContainer","parentNode","node","setTimeout","normalize","$node","position","offset","left","$el","top","height","lineHeight","$iframe","iframePosition","contentWindow","document","scrollTop","remove"],"mappings":";;;;;;;AAAAA,QACE,iBACA,iBACA,aACA,SAAUC,GACV,aAMA,SAASC,EAAiBC,EAASC,EAAWC,GAC5CC,KAAKC,WAAWJ,EAASC,EAAWC,GAGtCJ,EAAEO,OAAON,EAAgBO,UAAWR,EAAES,GAAGC,aAAaC,QAAQH,WAM5DI,OAAQ,SAAUC,EAAOC,EAAUC,GACjC,IAAIC,EAAMX,KAAKY,yBAEXC,EAAMb,KAAKc,GAAGC,cAAcC,eAE5BC,EAAQJ,EAAIK,WAAW,GACvBC,EAAYF,EAAMG,aACtBD,EAAUE,mBAAmBJ,EAAMK,gBACnC,IAGIC,EAFAC,EADUL,EAAUM,WACLC,UAAUT,EAAMU,aAC/BC,EAAYnB,EAASoB,QAAQrB,EAAOE,GAExC,QAAyB,IAAdkB,EAA2B,CAChCjC,EAAEmC,QAAQF,KACZJ,EAAOI,EAAU,GAAKJ,EACtBI,EAAYA,EAAU,IAExBL,EAAS5B,EAAEoC,WAAWtB,EAASuB,OAASvB,EAASuB,MAAMrB,GAAOF,EAASuB,MACvErB,EAAMA,EAAIkB,QAAQN,EAAQK,GACrBC,QAAQ,KAAM,SACnBZ,EAAMI,mBAAmBJ,EAAMK,gBAC/BL,EAAMgB,iBAGN,IAAIC,EAAalC,KAAKc,GAAGC,cAAcoB,cAAc,OACrDD,EAAWE,UAAYzB,EACvB,IAAI0B,EAAcrC,KAAKc,GAAGC,cAAcoB,cAAc,OACtDE,EAAYD,UAAYZ,EAMxB,IAHA,IACIc,EACAC,EAFAC,EAAWxC,KAAKc,GAAGC,cAAc0B,yBAG9BH,EAAYJ,EAAWQ,YAC7BH,EAAYC,EAASG,YAAYL,GAElC,KAAOA,EAAYD,EAAYK,YAC9BF,EAASG,YAAYL,GAItBrB,EAAM2B,WAAWJ,GACjBvB,EAAM4B,cAAcN,GAEpBtB,EAAM6B,UAAS,GACfjC,EAAIkC,kBACJlC,EAAImC,SAAS/B,KAgBjBgC,0BAA2B,WACzB,IAAIhC,EAAQjB,KAAKc,GAAGC,cAAcC,eAAeE,WAAW,GAAGE,aAC3D8B,EAAcjC,EAAMkC,aAAaC,WACjCC,EAAOrD,KAAKc,GAAGC,cAAcoB,cAAc,QAC/ClB,EAAM2B,WAAWS,GACjBpC,EAAMI,mBAAmBgC,GACzBpC,EAAMgB,iBACNqB,WAAW,WAAaJ,EAAYK,aAAgB,GACpD,IAAIC,EAAQ7D,EAAE0D,GACVI,EAAWD,EAAME,SAOrB,GANAD,EAASE,MAAQ3D,KAAK4D,IAAIF,SAASC,KACnCF,EAASI,KAAOL,EAAMM,SAAW9D,KAAK4D,IAAIF,SAASG,IACnDJ,EAASM,WAAaP,EAAMM,SAIxB9D,KAAKF,UAAUkE,QAAS,CAC1B,IAAIC,EAAiBjE,KAAKF,UAAUkE,QAAQN,SAC5CD,EAASI,KAAOI,EAAeJ,IAC/BJ,EAASE,MAAQM,EAAeN,KAGhCF,EAASI,KAAOlE,EAAEK,KAAKF,UAAUkE,QAAQ,GAAGE,cAAcC,UAAUC,YAItE,OADAZ,EAAMa,SACCZ,GAWT7C,uBAAwB,WACtB,IAAIK,EAAQjB,KAAKc,GAAGC,cAAcC,eAAeE,WAAW,GACxDC,EAAYF,EAAMG,aAEtB,OADAD,EAAUE,mBAAmBJ,EAAMK,gBAC5BH,EAAUM,WAAWC,UAAU,EAAGT,EAAMU,gBAInDhC,EAAES,GAAGC,aAAaT,gBAAkBA","file":"../content_editable.js","sourcesContent":["define([\n  \"skylark-jquery\",\n  \"./textcomplete\",\n  \"./adapter\"\n],function ($) {\n  'use strict';\n\n  // ContentEditable adapter\n  // =======================\n  //\n  // Adapter for contenteditable elements.\n  function ContentEditable (element, completer, option) {\n    this.initialize(element, completer, option);\n  }\n\n  $.extend(ContentEditable.prototype, $.fn.textcomplete.Adapter.prototype, {\n    // Public methods\n    // --------------\n\n    // Update the content with the given value and strategy.\n    // When an dropdown item is selected, it is executed.\n    select: function (value, strategy, e) {\n      var pre = this.getTextFromHeadToCaret();\n      // use ownerDocument instead of window to support iframes\n      var sel = this.el.ownerDocument.getSelection();\n      \n      var range = sel.getRangeAt(0);\n      var selection = range.cloneRange();\n      selection.selectNodeContents(range.startContainer);\n      var content = selection.toString();\n      var post = content.substring(range.startOffset);\n      var newSubstr = strategy.replace(value, e);\n      var regExp;\n      if (typeof newSubstr !== 'undefined') {\n        if ($.isArray(newSubstr)) {\n          post = newSubstr[1] + post;\n          newSubstr = newSubstr[0];\n        }\n        regExp = $.isFunction(strategy.match) ? strategy.match(pre) : strategy.match;\n        pre = pre.replace(regExp, newSubstr)\n            .replace(/ $/, \"&nbsp\"); // &nbsp necessary at least for CKeditor to not eat spaces\n        range.selectNodeContents(range.startContainer);\n        range.deleteContents();\n        \n        // create temporary elements\n        var preWrapper = this.el.ownerDocument.createElement(\"div\");\n        preWrapper.innerHTML = pre;\n        var postWrapper = this.el.ownerDocument.createElement(\"div\");\n        postWrapper.innerHTML = post;\n        \n        // create the fragment thats inserted\n        var fragment = this.el.ownerDocument.createDocumentFragment();\n        var childNode;\n        var lastOfPre;\n        while (childNode = preWrapper.firstChild) {\n        \tlastOfPre = fragment.appendChild(childNode);\n        }\n        while (childNode = postWrapper.firstChild) {\n        \tfragment.appendChild(childNode);\n        }\n        \n        // insert the fragment & jump behind the last node in \"pre\"\n        range.insertNode(fragment);\n        range.setStartAfter(lastOfPre);\n        \n        range.collapse(true);\n        sel.removeAllRanges();\n        sel.addRange(range);\n      }\n    },\n\n    // Private methods\n    // ---------------\n\n    // Returns the caret's relative position from the contenteditable's\n    // left top corner.\n    //\n    // Examples\n    //\n    //   this._getCaretRelativePosition()\n    //   //=> { top: 18, left: 200, lineHeight: 16 }\n    //\n    // Dropdown's position will be decided using the result.\n    _getCaretRelativePosition: function () {\n      var range = this.el.ownerDocument.getSelection().getRangeAt(0).cloneRange();\n      var wrapperNode = range.endContainer.parentNode;\n      var node = this.el.ownerDocument.createElement('span');\n      range.insertNode(node);\n      range.selectNodeContents(node);\n      range.deleteContents();\n      setTimeout(function() { wrapperNode.normalize(); }, 0);\n      var $node = $(node);\n      var position = $node.offset();\n      position.left -= this.$el.offset().left;\n      position.top += $node.height() - this.$el.offset().top;\n      position.lineHeight = $node.height();\n      \n      // special positioning logic for iframes\n      // this is typically used for contenteditables such as tinymce or ckeditor\n      if (this.completer.$iframe) {\n        var iframePosition = this.completer.$iframe.offset();\n        position.top += iframePosition.top;\n        position.left += iframePosition.left;\n        // We need to get the scrollTop of the html-element inside the iframe and not of the body-element,\n        // because on IE the scrollTop of the body-element (this.$el) is always zero.\n        position.top -= $(this.completer.$iframe[0].contentWindow.document).scrollTop();\n      }\n      \n      $node.remove();\n      return position;\n    },\n\n    // Returns the string between the first character and the caret.\n    // Completer will be triggered with the result for start autocompleting.\n    //\n    // Example\n    //\n    //   // Suppose the html is '<b>hello</b> wor|ld' and | is the caret.\n    //   this.getTextFromHeadToCaret()\n    //   // => ' wor'  // not '<b>hello</b> wor'\n    getTextFromHeadToCaret: function () {\n      var range = this.el.ownerDocument.getSelection().getRangeAt(0);\n      var selection = range.cloneRange();\n      selection.selectNodeContents(range.startContainer);\n      return selection.toString().substring(0, range.startOffset);\n    }\n  });\n\n  $.fn.textcomplete.ContentEditable = ContentEditable;\n\n});\n"]}